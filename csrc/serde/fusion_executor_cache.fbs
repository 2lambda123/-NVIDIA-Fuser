// clang-format off
/*
 * SPDX-FileCopyrightText: Copyright (c) 2023-present NVIDIA CORPORATION & AFFILIATES.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 */
namespace nvfuser.serde;

// This indicates the flatbuffer compatibility. The number will bump up when a
// breaking change is applied to the schema.
file_identifier "NV00";

enum ArgType:int {
  PhiloxCudaState,
  Long,
  Double,
  ComplexDouble,
  Bool,
  Tensor,
  CpuScalarTensor
}

enum KernelIndexMode:int {
  INT32,
  INT64
}

union ArgAbstractData {
  Long,
  Double,
  ComplexDouble,
  Bool,
  PhiloxCudaState,
  Tensor,
  CpuScalarTensor
}

// TODO CpuScalarTensor

table PhiloxCudaState {
  seed : ulong;
  offset : ulong;
}

table TensorArgCodegen {
  alignment_size : ulong;
  size : [long];
  stride : [long];
  ndims : long;
  dtype: DataType;
}

table ArgAbstract {
  type : ArgType;
  data  : ArgAbstractData;
}

table KernelArgumentHolder {
  arguments : [ArgAbstract];
  device_index : char;
  cache_id : ulong;
  index_mode : KernelIndexMode;
}

table LaunchParams {
  gdimx : int64_t;
  gdimy : int64_t;
  gdimz : int64_t;
  bdimx : int64_t;
  bdimy : int64_t;
  bdimz : int64_t;
  smem : int64_t;
  output_sizes : [[long]];
}

table CompileParams {
  index_type : PrimDataType;
  maxrregcount : int;
  enable_magic_zero : bool;
}

// struct NvrtcFunction
// CUmodule module
// CUfunction function
struct NvrtcFunction {
  module : [char];
  function : [char];

  CUmodule module = CUmodule();
  CUfunction function = CUfunction();
};

table GlobalBufferInfo {
  sizes : [long];
  strides : [long];
  type : DataType;
  zero_init : bool;
  is_profile_buffer : bool;
}

table ExecutorEntry {
    bool init = false;
    launch_params : LaunchParams;
    // Aliased output and input mappings
    output_aliases : [int];
    input_aliases : [int];
    outputs : [GlobalBufferInfo];
    intermediates : [GlobalBufferInfo];
    rand_offset : ulong;
};

// VectorizedSetInfo
table VectorizedSetInfo {
  // Producer of a vectorized set
  TensorView* producer_tv = nullptr;

  // Consumer of a vectorized set
  TensorView* consumer_tv = nullptr;

  // Number of elements to vectorize
  int word_size = -1;

  // Vectorized domain
  IterDomain* vectorized_leaf_id = nullptr;

  // Right-most root dependent domain of the leaf domain
  IterDomain* vectorized_root_id = nullptr;
  
  // All of the dependent root domains that are contiguously merged
  std::unordered_set<IterDomain*> contig_root_ids;
};

table KernelSummary {
  // Indicate the need to generate random numbers
  max_rng_offsets : int = -1;

  // Do we have any grid reduction in a loop, or grid reductions dependent on grid reductions
  has_cooperative_grid_reduction : bool;

  // ceilDiv extents that must be divisible
  lhs_splits_to_validate : [long];
  rhs_splits_to_validate : [long];

  // Track which tensor views are inputs or outputs of a vectorized operation
  // and their maximum vectorized access size
  // map<TensorView*, int> vectorized_accesses;
  vectorized_accesses_tv_keys : [ulong]
  vectorized_accesses_size : [int]

  // Track information on vectorized set operations for runtime validation
  vectorized_set_info : [VectorizedSetInfo];
}

// skipped potential fields:
// lowered : GpuLower
table FusionExecutor {
    configured_device_smem : ulong;
    maybe_available_smem : ulong;
    device_smem_limit: ulong;
    warp_size: int;
    fusion_id: int;
    // shared static value
    fusion_id_counter : int;
    kernel_code : string;
    executor_entry_lookup_keys : [ulong]
    executor_entry_lookup_values : [ExecutorEntry]
    compile_params : CompileParams;
    compiled_kernel : NvrtcFunction;
    launch_params : LaunchParams;
    kernel_summary : KernelSummary;
    used_tvs : [ulong];
}

// unscheduled_fusion : Fusion - defined by traversing Trie in FusionCache
table FusionKernelRuntime {
    args : KernelArgumentHolder;
    executors : [FusionExecutor];
}

struct EncodingEntry {
  id: ulong;
  lru_iter: ulong;
}

table InputsIdLookup {
  max_cache_size : ulong;
  currrent_id : ulong;
  lru_cache : [string];

  // define map<std::string, EncodingEntry> encoding_lookup
  encoding_lookup_keys : [strings];
  encoding_lookup_values : [EncodingEntry];
}

// implicit fields
// unscheduled_fusion : Fusion - defined by traversing Trie in FusionCache
table FusionExecutorCache {
  inputs_cache : InputsIdLookup

  // define map<size_t, vector<FusionKernelRuntime>> kernel_runtimes
  kernel_runtime_keys : [ulong]
  kernel_runtime_values : [FusionKernelRuntime]

  // define map<size_t, FusionKernelRuntime> id_to_kernel_runtime
  kernel_cache_keys : [ulong]
  // indices into kernel_runtime_values
  kernel_cache_values : [ulong]
}